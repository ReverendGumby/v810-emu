Instruction fetch
-----------------

Instructions are stored little-endian and can be 16-bit or 32-bit
wide.  The size can be determined from the first 6 bits.  Pre-fetching
is used to minimize fetch delays for 32-bit instructions that are
wrapped or spread across two words.

PC1:        Bit 1 of PC. Next ins. will start mid-word.
wrapped:    Value of wrap from last fetch cycle
pdh/l:      Low/high halfword on I-bus
pdh/l32:    Low/high halfword on I-bus is start of 32-bit ins.
idrh:       Last high halfword fetched from I-bus

irh/l:      Instruction to forward to ID
PCi:        Value to add to PC. PCn = PC + PCi
ia:         Next address to issue to I-bus (bits 1:0 are ignored)
wrap:       We fetched the low halfword of a 32-bit ins.
flush:      IF incomplete; needs to fetch high halfword. Stall ID.


PC1  wrapped  pdh32  pdl32 |  irh  irl   PCi  ia     wrap  flush
----------------------------------------------------------------
0    0        0      0     |  'X   pdl   2    PCn    0     0
1    0        0      x     |  'X   pdh   2    PCn    0     0

0    0        x      1     |  pdh  pdl   4    PCn    0     0
0    0        1      0     |  'X   pdl   2    PCn+2  1     0

1    0        1      x     |  'X   '0    0    PCn+2  1     1
1    1        0      x     |  pdl  idrh  4    PCn    0     0
1    1        1      x     |  pdl  idrh  4    PCn+2  1     0


======================================================================

Pipeline timing for [3] interlock examples
------------------------------------------

Given:
- There is no register or flag forwarding
- Flags are generated in MA
- Decision to branch is made in EX

Register Hazard code, left side -- 545ms = 13 cycles/loop

   Clock cyle              0  1  2  3  4  5  6  7  8  9  10 11 12 13 ..
    movea 1000, r0, r10    IF ID EX MA WB
    st.b  r0, [r10]           IF       ID EX MA WB
    mov   1, r11                       IF ID EX MA WB
    add   r11, r12                        IF       ID EX MA WB
    add   -1, r20                                  IF ID EX MA WB
    bnz   LABEL                                       IF ID    EX MA WB
    ...                                                  IF    ID
    ...                                                        IF
    movea 1000, r0, r10                                           IF ID ..

Register Hazard code, right side -- 461ms = 11 cycles/loop

   Clock cyle              0  1  2  3  4  5  6  7  8  9  10 11 ..
    movea 1000, r0, r10    IF ID EX MA WB
    mov   1, r11              IF ID EX MA WB
    add   r11, r12               IF       ID EX MA WB
    st.b  r0, [r10]                       IF ID EX MA WB
    add   -1, r20                            IF ID EX MA WB
    bnz   LABEL                                 IF ID    EX MA WB
    ...                                            IF    ID
    ...                                                  IF
    movea 1000, r0, r10                                     IF ID ..

Flag Hazard code, left side -- 377ms = 9 cycles/loop *

   Clock cyle              0  1  2  3  4  5  6  7  8  9  ..
    st.b  r0, [r10]        IF ID EX MA WB
    add   1, r10              IF ID EX MA WB
    add   -1, r20                IF ID EX MA WB
    bnz   LABEL                     IF ID    EX MA WB
    ...                                IF    ID
    ...                                      IF
    st.b  r0, [r10]                                   IF ID ..

Flag Hazard code, right side -- 335ms = 8 cycles/loop *

   Clock cyle              0  1  2  3  4  5  6  7  8  ..
    st.b  r0, [r10]        IF ID EX MA WB
    add   -1, r20             IF ID EX MA WB
    movea 1, r10, r10            IF ID EX MA WB
    bnz   LABEL                     IF ID EX MA WB
    ...                                IF ID
    ...                                   IF
    st.b  r0, [r10]                                IF ID ..

* TODO: There's another 2 cycle delay coming from somewhere.


======================================================================

Arithmetic bit string instructions
----------------------------------

MOVBSU, NOTBSU, ANDBSU, ANDNBSU, ORBSU ORNBSU, XORBSU, XORNBSU

  r26 = string dest. start bit offset
  r27 = string src. start bit offset
  r28 = string length (bits)
  r29 = string dest. addr.
  r30 = string src. addr.

Above regs are read into internal work registers, and written back at
the end or exception.

Work registers:
  dbo - r26
  sbo - r27
  cnt - r28
  dst - r29
  src - r30
  sr - shift register, 64 bits

Operation pseudo-code
---------------------

Temporary variables:
  mask - 32 bits
  dr - 32 bits
  n - 5 bits

# Setup
src = r30
dst = r29
cnt = r28
sbo = r27
dbo = r26

# Initialize sr
if sbo >= dbo:
    sr >>= 32
    ld.w src, sr[32+:32]
    src ++

# Partial first dest. word
if dbo != 0:
    sr >>= 32
    ld.w src, sr[32+:32]
    src ++

    n = 32 - dbo
    mask = -32'd1 >> n
    if n > cnt:
        n = cnt
        mask = mask | (-32'd1 << (dbo + n))
    ld.w dst, dr
    # (sbo-dbo) should be treated as unsigned
    dr &= mask
    dr |= sr[5'(sbo-dbo)+:32] & ~mask
    st.w dst, dr
    dst ++

    sbo += n
    dbo += n
    cnt -= n

# Full dest. word loop
while cnt >= 32:
    sr >>= 32
    if cnt > 32 or sbo:
        ld.w src, sr[32+:32]
        src ++

    ld.w dst, dr
    # Perform bit string operation here. Copy is shown.
    dr = sr[sbo+:32]
    st.w dst, dr
    dst ++
    cnt -= 32

# Partial last dest. word
if cnt:
    sr >>= 32
    ld.w src, sr[32+:32]

    mask = -32'd1 << cnt
    ld.w dst, dr
    dr &= mask
    # Perform bit string operation here.
    dr |= sr[sbo+:32] & ~mask
    st.w dst, dr

    cnt = 0

# Finalize
r30 = src
r29 = dst
r28 = cnt
r27 = sbo
r26 = dbo


======================================================================


References
----------
[1] V810 Family User's Manual Architecture
[2] V810 Family User's Manual Hardware
[3] v810-seminar-slides-1-introduction-architecture-tips.pdf
[4] v810-seminar-slides-2-v810-programming.pdf
